
Logic flow for entire Addon:

Startup() is called.
Startup fires a number of critical building functions which are required for the modules to operate.
At startup, .xml files load with values.  If a new install has occurred, these files are created and layed down during the startup process using 
imbedded .xml files.
TODO:  Check if settings checkboxes enable huds, etc and subscribe services and start them on login.
TODO:  Make control checkboxes that enable the modules and have them subscribe/desubscribe the control events for the modules upon click.


Control events are handled by subscription when certain modules are enabled.  These control events are all located and subscribed to at the beginning of the 
individual modules.



CorpseTracker.cs:   Provides corpse tracking fuctions.  90% functional.  May require some debugging
LandscapeTracer.cs:  Provides a sixthsense like fuction.  90% functional.  My require some debugging
ItemTracker.cs:		Provides loot tracking functions on landscape and in corpses/chests.  40% functional.  Requires significant debugging.  
					Untested code bits are currently disabled.
IdentfiedObject.cs:  Has the wrapper class for the WorldObject identification and sorting process.  Still under development
					Needs Mag-Tools dps report string added for weapons.  Will be the jumping in point for changeover to GearScore ID process (planned).
TextFunctions.cs:  Scheculed for overhaul as soon as IdentifedObject.cs is completed.


//TOMISH:  mWaitingForIDTimer = new WindowsTimer();

Why?  I'd encourage you to simply your code and take advantage of the built in decal features.  ItemTracker.cs shows how to use requestID and EchoFilter to
quickly ID and recover your IDs from decal without need for a timer.

The proceess looks like this:

//Call this at startup to setup echofilter
void SubscribeInventoryEvents()
{
	try
	{
		Core.EchoFilter.ServerDispatch += new EventHandler<NetworkMessageEventArgs>(ServerDispatchInventory);
	}
	catch{}
}

//In your ID program load them into the built in DecalID queue
foreach(WorldObject wo in ItemsWithoutIDs)
{
	InventoryWaitingIDsList.Add(wo.Id);
	Core.Actions.RequestId(wo.Id);
}

private void ServerDispatchInventory(object sender, Decal.Adapter.NetworkMessageEventArgs e)
{
   	int iEvent = 0;
    try
       {
      	if(e.Message.Type == AC_GAME_EVENT)
       	{
	   		try
	        {
	           	iEvent = Convert.ToInt32(e.Message["event"]);
            }
            catch{}
	        if(iEvent == GE_IDENTIFY_OBJECT)
            {
               	 OnInventoryItem(e.Message);
            }
       
      	}
       }
            catch (Exception ex)
            {
                LogError(ex);
            }
        }

		private void OnInventoryItem(Decal.Adapter.Message pMsg)
		{
			try
			{
				if(!bInventoryEnabled) {return;}  //If you want to enable/disable it
        		int PossibleInventoryID = Convert.ToInt32(pMsg["object"]);
        		//Read and report manual IDs, but keep them out of 
        		if(!IInventoryWaitingIDsList.Contains(PossibleInventoryID)) {return;}
        		else
        		{
        			DoInventoryStuff();
        		}

			} 
			catch (Exception ex) {LogError(ex);}
		}



